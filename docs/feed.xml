<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Today, I Learned</title>
<id>https://jaredkrinke.github.io/til/</id>
<link rel="self" href="https://jaredkrinke.github.io/til/feed.xml"/>
<link rel="alternate" href="https://jaredkrinke.github.io/til/"/>
<author>
<name>Today, I Learned</name>
</author>
<updated>2026-02-13T00:00:00.000Z</updated>

<entry>
<title>Use &quot;GO386=softfloat&quot; to compile Go for Pentium</title>
<id>https://jaredkrinke.github.io/til/go386-softfloat-for-pentium.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/go386-softfloat-for-pentium.html"/>
<updated>2026-02-13T00:00:00.000Z</updated>
<summary type="text">Use &quot;GO386=softfloat&quot; to compile Go for Pentium</summary>
<content type="html">&lt;p&gt;Cross-compiling is trivial with pure-Go projects. For example, to compile for a Pentium (maybe even a 486 DX?) running NetBSD, just set a few variables:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOOS=netbsd GOARCH=386 GO386=softfloat make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;GO386=softfloat&lt;/code&gt; setting is necessary for Pentium I/II--without specifying it, &lt;a href=&quot;https://github.com/golang/go/issues/40255&quot;&gt;Go 1.16 requires SSE2 by default for &amp;quot;GOARCH=386&amp;quot;&lt;/a&gt;, and I believe that&#039;s only supported on Pentium 4+.&lt;/p&gt;
&lt;p&gt;Why do I know this? I have a late &#039;90s Dell Latitude CP (Pentium 233 MHz with 128 MB RAM) running NetBSD and I wanted to run the &lt;a href=&quot;https://aerc-mail.org/&quot;&gt;aerc&lt;/a&gt; mail client on it. Unfortunately, the prebuilt &amp;quot;i386&amp;quot; NetBSD package crashed with &lt;code&gt;SIGILL&lt;/code&gt; (illegal instruction). Loading the core dump into GDB revealed that an &lt;code&gt;xorps&lt;/code&gt; instruction was the problem because that instruction was introduced as part of SSE2 (well after my Pentium was manufactured). I have not yet investigated whether or not it&#039;s expected for prebuilt binary packages on &amp;quot;i386&amp;quot; NetBSD to require a Pentium 4, but in my case recompiling the pure-Go aerc project was trivial and I can now read modern email on a nearly 30 year old computer.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Use &quot;desat&quot; option to tweak HDR-to-SDR in Handbrake</title>
<id>https://jaredkrinke.github.io/til/hdr-to-sdr-in-handbrake.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/hdr-to-sdr-in-handbrake.html"/>
<updated>2026-01-18T00:00:00.000Z</updated>
<summary type="text">Use &quot;desat&quot; option to tweak HDR-to-SDR in Handbrake</summary>
<content type="html">&lt;p&gt;When converting HDR video to SDR in Handbrake, e.g. for playing on a Roku TV, you can &lt;strong&gt;customize the saturation&lt;/strong&gt; using the &lt;code&gt;desat&lt;/code&gt; setting (under &amp;quot;Custom&amp;quot; for &amp;quot;Colorspace&amp;quot;). Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;primaries=bt709:transfer=bt709:matrix=bt709:tonemap=hable:desat=0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ran into this because my Roku TV would report an error (something about &amp;quot;couldn&#039;t retrieve the data for the selected item from the server&amp;quot;) when trying to play some videos via Jellyfin. The culprit turned out to be that &lt;a href=&quot;https://jellyfin.org/docs/general/clients/codec-support/#hdr-support&quot;&gt;Roku TVs don&#039;t support HDR in Jellyfin&lt;/a&gt;, and I needed to convert the HDR video to SDR.&lt;/p&gt;
&lt;p&gt;Unfortunately, &lt;strong&gt;the default tonemapping resulted in crazy saturated colors&lt;/strong&gt;, so I needed to decrease the saturation somehow. Fortunately, someone had already pointed out this and many other options in &lt;a href=&quot;https://github.com/HandBrake/HandBrake/issues/7198&quot;&gt;this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Use &quot;sh -c&quot; to supply multiple commands to &quot;entr&quot;</title>
<id>https://jaredkrinke.github.io/til/multiple-commands-for-entr.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/multiple-commands-for-entr.html"/>
<updated>2025-12-29T00:00:00.000Z</updated>
<summary type="text">Use &quot;sh -c&quot; to supply multiple commands to &quot;entr&quot;</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/eradman/entr&quot;&gt;entr&lt;/a&gt; lets you re-run commands when files change. It&#039;s great for iterating on code because you don&#039;t have to switch contexts; your code just re-runs when you save the file.&lt;/p&gt;
&lt;p&gt;If you need to run multiple commands or redirect input/output, just invoke your shell, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls foo.c |entr sh -c &amp;quot;make &amp;amp;&amp;amp; make test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
</entry>
<entry>
<title>Use &quot;background=dark&quot; in Vim</title>
<id>https://jaredkrinke.github.io/til/vim-dark-mode.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/vim-dark-mode.html"/>
<updated>2025-12-28T00:00:00.000Z</updated>
<summary type="text">Use &quot;background=dark&quot; in Vim</summary>
<content type="html">&lt;p&gt;Use &lt;code&gt;:set background=dark&lt;/code&gt; in Vim when you&#039;re using a console with a dark background (i.e. every console I&#039;ve ever used).&lt;/p&gt;
&lt;p&gt;I don&#039;t understand why this isn&#039;t the default for Vim, but at least I can finally now read comment blocks.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Busybox includes a DHCP server (&quot;udhcpd&quot;)</title>
<id>https://jaredkrinke.github.io/til/busybox-dhcp-server.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/busybox-dhcp-server.html"/>
<updated>2025-12-06T00:00:00.000Z</updated>
<summary type="text">Busybox includes a DHCP server (&quot;udhcpd&quot;)</summary>
<content type="html">&lt;p&gt;On an isolated network, you may want to run a DHCP server. Luckily, you might already have one installed via Busybox:&lt;/p&gt;
&lt;p&gt;Just create a symlink to &lt;code&gt;busybox&lt;/code&gt; named &lt;code&gt;udhcpd&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Sample config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface eth0

start 172.16.0.50
end 172.16.0.99

option subnet 255.255.255.0
option router 172.16.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just run the symlinked binary with the config file as an argument (&lt;code&gt;-f&lt;/code&gt; runs in the foreground, for monitornig purposes):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./udhcpd -f udhcpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The config above only assigns IPs on the &lt;code&gt;eth0&lt;/code&gt; interface (useful if you&#039;re e.g. routing to a VPN on another interface), providing IPs on the specified range, with a gateway of &lt;code&gt;172.16.0.1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Oddly, &lt;code&gt;netstat -tulpn&lt;/code&gt; shows the process listening on all IPs, but it didn&#039;t respond on other interfaces, so it seems to work as intended. I wouldn&#039;t recommend running a Busybox DHCP server on an exposed network, just in case.&lt;/p&gt;
&lt;p&gt;My use case was running an isolated network of vintage computers locally and routing them through a WireGuard VPN over the Internet to other locations. Having a DHCP server allowed me to just plug a router into a Raspberry Pi running WireGuard and this DHCP server.&lt;/p&gt;
</content>
</entry>
</feed>
