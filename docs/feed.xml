<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Today, I Learned</title>
<id>https://jaredkrinke.github.io/til/</id>
<link rel="self" href="https://jaredkrinke.github.io/til/feed.xml"/>
<link rel="alternate" href="https://jaredkrinke.github.io/til/"/>
<author>
<name>Today, I Learned</name>
</author>
<updated>2025-12-01T00:00:00.000Z</updated>

<entry>
<title>FFmpeg can be used for batch lossless video cutting</title>
<id>https://jaredkrinke.github.io/til/batch-lossless-cut-with-ffmpeg.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/batch-lossless-cut-with-ffmpeg.html"/>
<updated>2025-12-01T00:00:00.000Z</updated>
<summary type="text">FFmpeg can be used for batch lossless video cutting</summary>
<content type="html">&lt;p&gt;Sadly, not many video editing tools support lossless cutting -- and even fewer support batch processing.&lt;/p&gt;
&lt;p&gt;Fortunately, FFmpeg supports lossless cutting using the &lt;code&gt;-ss hh:mm:ss&lt;/code&gt; option and, being a command line tool, it can be used for batch processing.&lt;/p&gt;
&lt;p&gt;Here&#039;s an example (on POSIX) that cuts roughly the first 26 seconds off of each video in &lt;code&gt;Videos/&lt;/code&gt; (lossless and aligned to keyframes), putting the resulting videos into &lt;code&gt;out/&lt;/code&gt; (you can&#039;t edit in place losslessly):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find Videos -name &#039;*.mp4&#039; -exec ffmpeg -i {} -ss 26 -c copy out/{} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;find&lt;/code&gt; command runs the &lt;code&gt;-exec ...&lt;/code&gt; command for each &lt;code&gt;*.mp4&lt;/code&gt; file, with &lt;code&gt;{}&lt;/code&gt; substituted for the filename (including any spaces--also note the &lt;code&gt;\;&lt;/code&gt; at the end), so the FFmpeg command line is similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -i video.mp4 -ss 26 -c copy out/video.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explanation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-i video.mp4&lt;/code&gt;: Opens &lt;code&gt;video.mp4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ss 26&lt;/code&gt;: Only keeps the video starting near 26 seconds (next keyframe)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c copy&lt;/code&gt;: Copies video/audio streams (i.e. losslessly cuts) -- this option is needed to avoid re-encoding!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out/video.mp4&lt;/code&gt;: Writes the output to &lt;code&gt;out/video.mp4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: on Windows, you could use &lt;code&gt;for %i in (*.mp4) do ffmpeg -i %i ...&lt;/code&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Use &quot;find -exec&quot; instead of &quot;xargs&quot;</title>
<id>https://jaredkrinke.github.io/til/find-exec-instead-of-xargs.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/find-exec-instead-of-xargs.html"/>
<updated>2025-11-30T00:00:00.000Z</updated>
<summary type="text">Use &quot;find -exec&quot; instead of &quot;xargs&quot;</summary>
<content type="html">&lt;p&gt;If you need to run a command on each file under a directory structure, use the &lt;code&gt;-exec&lt;/code&gt; option of &lt;code&gt;find&lt;/code&gt; (it will substitute a file for each &lt;code&gt;{}&lt;/code&gt;, and you must terminate with &lt;code&gt;\;&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find some-dir -name &#039;*.mp4&#039; -exec ffmpeg -i {} out/{} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;find ... -exec&lt;/code&gt; is better than piping to &lt;code&gt;xargs&lt;/code&gt; because it handles filenames with spaces seamlessly.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Use Ctrl+p, Ctrl+q to detach from containers</title>
<id>https://jaredkrinke.github.io/til/detach-from-docker-container.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/detach-from-docker-container.html"/>
<updated>2025-11-29T00:00:00.000Z</updated>
<summary type="text">Use Ctrl+p, Ctrl+q to detach from containers</summary>
<content type="html">&lt;p&gt;You can detach from a running, interactive Docker/Podman terminal using &lt;strong&gt;Ctrl+p, Ctrl+q&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;For example, if you start up a &lt;a href=&quot;https://jellyfin.org/&quot;&gt;Jellyfin&lt;/a&gt; container and then want to leave it running, you can just detach.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Use &quot;socat&quot; for temporarily forwarding ports</title>
<id>https://jaredkrinke.github.io/til/forward-ports-with-socat.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/forward-ports-with-socat.html"/>
<updated>2025-10-29T00:00:00.000Z</updated>
<summary type="text">Use &quot;socat&quot; for temporarily forwarding ports</summary>
<content type="html">&lt;p&gt;Temporarily forward ports on Linux with the &lt;code&gt;socat&lt;/code&gt; tool:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;socat UDP4-LISTEN:12345,fork,reuseaddr,bind=127.0.0.1 UDP4:1.2.3.4:34567
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This forwards UDP datagrams from 127.0.0.1 on port 12345 to a remote host 1.2.3.4, port 34567.  Use &amp;quot;TCP&amp;quot; instead of &amp;quot;UDP&amp;quot; to forward TCP streams.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt; means it will fork a new process for each remote host&lt;/li&gt;
&lt;li&gt;UDP is connectionless, so &lt;code&gt;socat&lt;/code&gt; UDP forks won&#039;t automatically terminate unless a timeout is specified using &lt;code&gt;-T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reuseaddr&lt;/code&gt; might not be needed -- I haven&#039;t tested it in depth&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>OpenSuperClone can clone failing rotational hard disks</title>
<id>https://jaredkrinke.github.io/til/clone-failing-hdd.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/clone-failing-hdd.html"/>
<updated>2025-10-01T00:00:00.000Z</updated>
<summary type="text">OpenSuperClone can clone failing rotational hard disks</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/ISpillMyDrink/OpenSuperClone&quot;&gt;OpenSuperClone&lt;/a&gt; can cautiously clone failing rotational hard disks, similar to &lt;a href=&quot;https://www.gnu.org/software/ddrescue/&quot;&gt;ddrescue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once cloned, you can safely attempt reading from the clone and maybe even try repairing the file system or scanning for orphaned files.&lt;/p&gt;
</content>
</entry>
</feed>
