<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Today, I Learned</title>
<id>https://jaredkrinke.github.io/til/</id>
<link rel="self" href="https://jaredkrinke.github.io/til/feed.xml"/>
<link rel="alternate" href="https://jaredkrinke.github.io/til/"/>
<author>
<name>Today, I Learned</name>
</author>
<updated>2026-01-18T00:00:00.000Z</updated>

<entry>
<title>Use &quot;desat&quot; option to tweak HDR-to-SDR in Handbrake</title>
<id>https://jaredkrinke.github.io/til/hdr-to-sdr-in-handbrake.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/hdr-to-sdr-in-handbrake.html"/>
<updated>2026-01-18T00:00:00.000Z</updated>
<summary type="text">Use &quot;desat&quot; option to tweak HDR-to-SDR in Handbrake</summary>
<content type="html">&lt;p&gt;When converting HDR video to SDR in Handbrake, e.g. for playing on a Roku TV, you can &lt;strong&gt;customize the saturation&lt;/strong&gt; using the &lt;code&gt;desat&lt;/code&gt; setting (under &amp;quot;Custom&amp;quot; for &amp;quot;Colorspace&amp;quot;). Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;primaries=bt709:transfer=bt709:matrix=bt709:tonemap=hable:desat=0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ran into this because my Roku TV would report an error (something about &amp;quot;couldn&#039;t retrieve the data for the selected item from the server&amp;quot;) when trying to play some videos via Jellyfin. The culprit turned out to be that &lt;a href=&quot;https://jellyfin.org/docs/general/clients/codec-support/#hdr-support&quot;&gt;Roku TVs don&#039;t support HDR in Jellyfin&lt;/a&gt;, and I needed to convert the HDR video to SDR.&lt;/p&gt;
&lt;p&gt;Unfortunately, &lt;strong&gt;the default tonemapping resulted in crazy saturated colors&lt;/strong&gt;, so I needed to decrease the saturation somehow. Fortunately, someone had already pointed out this and many other options in &lt;a href=&quot;https://github.com/HandBrake/HandBrake/issues/7198&quot;&gt;this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Use &quot;sh -c&quot; to supply multiple commands to &quot;entr&quot;</title>
<id>https://jaredkrinke.github.io/til/multiple-commands-for-entr.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/multiple-commands-for-entr.html"/>
<updated>2025-12-29T00:00:00.000Z</updated>
<summary type="text">Use &quot;sh -c&quot; to supply multiple commands to &quot;entr&quot;</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/eradman/entr&quot;&gt;entr&lt;/a&gt; lets you re-run commands when files change. It&#039;s great for iterating on code because you don&#039;t have to switch contexts; your code just re-runs when you save the file.&lt;/p&gt;
&lt;p&gt;If you need to run multiple commands or redirect input/output, just invoke your shell, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls foo.c |entr sh -c &amp;quot;make &amp;amp;&amp;amp; make test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
</entry>
<entry>
<title>Use &quot;background=dark&quot; in Vim</title>
<id>https://jaredkrinke.github.io/til/vim-dark-mode.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/vim-dark-mode.html"/>
<updated>2025-12-28T00:00:00.000Z</updated>
<summary type="text">Use &quot;background=dark&quot; in Vim</summary>
<content type="html">&lt;p&gt;Use &lt;code&gt;:set background=dark&lt;/code&gt; in Vim when you&#039;re using a console with a dark background (i.e. every console I&#039;ve ever used).&lt;/p&gt;
&lt;p&gt;I don&#039;t understand why this isn&#039;t the default for Vim, but at least I can finally now read comment blocks.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Busybox includes a DHCP server (&quot;udhcpd&quot;)</title>
<id>https://jaredkrinke.github.io/til/busybox-dhcp-server.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/busybox-dhcp-server.html"/>
<updated>2025-12-06T00:00:00.000Z</updated>
<summary type="text">Busybox includes a DHCP server (&quot;udhcpd&quot;)</summary>
<content type="html">&lt;p&gt;On an isolated network, you may want to run a DHCP server. Luckily, you might already have one installed via Busybox:&lt;/p&gt;
&lt;p&gt;Just create a symlink to &lt;code&gt;busybox&lt;/code&gt; named &lt;code&gt;udhcpd&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Sample config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface eth0

start 172.16.0.50
end 172.16.0.99

option subnet 255.255.255.0
option router 172.16.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just run the symlinked binary with the config file as an argument (&lt;code&gt;-f&lt;/code&gt; runs in the foreground, for monitornig purposes):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./udhcpd -f udhcpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The config above only assigns IPs on the &lt;code&gt;eth0&lt;/code&gt; interface (useful if you&#039;re e.g. routing to a VPN on another interface), providing IPs on the specified range, with a gateway of &lt;code&gt;172.16.0.1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Oddly, &lt;code&gt;netstat -tulpn&lt;/code&gt; shows the process listening on all IPs, but it didn&#039;t respond on other interfaces, so it seems to work as intended. I wouldn&#039;t recommend running a Busybox DHCP server on an exposed network, just in case.&lt;/p&gt;
&lt;p&gt;My use case was running an isolated network of vintage computers locally and routing them through a WireGuard VPN over the Internet to other locations. Having a DHCP server allowed me to just plug a router into a Raspberry Pi running WireGuard and this DHCP server.&lt;/p&gt;
</content>
</entry>
<entry>
<title>FFmpeg can be used for batch lossless video cutting</title>
<id>https://jaredkrinke.github.io/til/batch-lossless-cut-with-ffmpeg.html</id>
<link rel="alternate" href="https://jaredkrinke.github.io/til/batch-lossless-cut-with-ffmpeg.html"/>
<updated>2025-12-01T00:00:00.000Z</updated>
<summary type="text">FFmpeg can be used for batch lossless video cutting</summary>
<content type="html">&lt;p&gt;Sadly, not many video editing tools support lossless cutting -- and even fewer support batch processing.&lt;/p&gt;
&lt;p&gt;Fortunately, FFmpeg supports lossless cutting using the &lt;code&gt;-ss hh:mm:ss&lt;/code&gt; option and, being a command line tool, it can be used for batch processing.&lt;/p&gt;
&lt;p&gt;Here&#039;s an example (on POSIX) that cuts roughly the first 26 seconds off of each video in &lt;code&gt;Videos/&lt;/code&gt; (lossless and aligned to keyframes), putting the resulting videos into &lt;code&gt;out/&lt;/code&gt; (you can&#039;t edit in place losslessly):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find Videos -name &#039;*.mp4&#039; -exec ffmpeg -i {} -ss 26 -c copy out/{} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;find&lt;/code&gt; command runs the &lt;code&gt;-exec ...&lt;/code&gt; command for each &lt;code&gt;*.mp4&lt;/code&gt; file, with &lt;code&gt;{}&lt;/code&gt; substituted for the filename (including any spaces--also note the &lt;code&gt;\;&lt;/code&gt; at the end), so the FFmpeg command line is similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -i video.mp4 -ss 26 -c copy out/video.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explanation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-i video.mp4&lt;/code&gt;: Opens &lt;code&gt;video.mp4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ss 26&lt;/code&gt;: Only keeps the video starting near 26 seconds (next keyframe)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c copy&lt;/code&gt;: Copies video/audio streams (i.e. losslessly cuts) -- this option is needed to avoid re-encoding!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out/video.mp4&lt;/code&gt;: Writes the output to &lt;code&gt;out/video.mp4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: on Windows, you could use &lt;code&gt;for %i in (*.mp4) do ffmpeg -i %i ...&lt;/code&gt;.&lt;/p&gt;
</content>
</entry>
</feed>
